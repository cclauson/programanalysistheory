%\documentclass[twocolumn,11pt]{article}
\documentclass[11pt]{article}
\usepackage{listings}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage[mathscr]{euscript}
\usepackage{verbatim}

\begin{document}

\title{Generalized While Programming Languages with Data Flow Analysis}
\author{C. E. Clauson}
%\affiliation{Somewhere}
\maketitle

\begin{abstract}
The While programming language has been defined in literature (source?).  In this paper we propose a class of programming languages called Generalized While languages, of which While is a specific case.  (Do we analyze anything?)
\end{abstract}

\section{Introduction}
(TODO: Put stuff here...)

We use the symbol $\mathbb{B}$ to represent the Boolean set, which has the members \texttt{true} and \texttt{false}.

\section{Generalized While}
For a given quintuple $(S, M, C, \delta_{1}, \delta_{2})$, we define the set $GW(S, M, C, \delta_{1}, \delta_{2})$ as a set of formulas, under the following assumptions:

\begin{itemize}
\item Each member of $S$ (state set) is finitely representable (and thus $S$ is at most countably infinite).
\item Each member of $M$ (primitive state mutations) can be represented by a finite formula (and thus $M$ is at most countably infinite).
\item Each member of $C$ (primitive conditions) can be represented by a finite formula (and thus $C$ is at most countably infinite).
\item The function $\delta_{1} : M \times S \rightarrow S$, which dictates how members of $M$ mutate members of $S$, is a Turing-computable function. 
\item The function $\delta_{2} : C \times S \rightarrow \mathbb{B}$, which evaluates members of $C$ at given states in $S$, is a Turing-computable function.
\end{itemize}

Under these conditions the set of Generalized While programs is defined inductively as follows:

\begin{itemize}
\item The special program \texttt{pass} is a Generalized While program.
\item Every member of $M$ is a Generalized While program.
\item If $p_{1}$ and $p_{2}$ are Generalized While programs, then $p_{1}$ \texttt{;} $p_{2}$ is a generalized while program, where \texttt{;} is the sequencing operator.
\item The special conditions \texttt{true} and \texttt{false} are conditions.
\item Every member of $C$ is a condition.
\item If $c_{1}$ and $c_{2}$ are conditions, then $c_{1}$ \texttt{\&\&} $c_{2}$, $c_{1}$ \texttt{||} $c_{2}$, and \texttt{!} $c_{1}$ are conditions.
\item If $p_{1}$ and $p_{2}$ are Generalized While programs and $c$ is a condition, then \texttt{if} $c$ \texttt{then} $p_{1}$ \texttt{else} $p_{2}$ is a Generalized While program.
\item If $p$ is a Generalized While program and $c$ is a condition, then \texttt{while} $c$ \texttt{do} $p$ is a Generalized While program.
\end{itemize}

We notice that the inductive definition is typed, specifically, we distinguish between two types, conditions and programs.  Conditions occur as subformulas in programs.  In our definition above, the reverse is not true.

\section{Evaluation of A Generalized While Program}

\subsection{Conditions}

We notice the following things:
\begin{enumerate}
\item Program formulas can contain condition formulas, but not vice versa.
\item The number of rules pertaining to condition evaluation is comparable in size to those for program evaluation.
\item Condition evaluation can be shown to be simpler in certain mathematical respects than program evaluation.
\end{enumerate}

For these reasons we will describe and analyze condition evaluation here separately from program evaluation.  Note that while these could be done together, this approach makes things somewhat simpler.

We define the following reduction rules for conditions:

\begin{description}

\item[CondPrim] If $c$ is a member of $C$ then $c \rightarrow \delta_{2}(c, s)$.

\item[CondRecurseOr] If $c_{1}$, $c_{1}'$ and $c_{2}$ are conditions and $c_{1} \rightarrow c_{1}'$, then
$c_{1}\texttt{||}c_{2} \rightarrow c_{1}'\texttt{||}c_{2}$.
\item[CondFalseOr] If $c$ is a condition then $\texttt{false||} c \rightarrow c$.
\item[CondTrueOr] If $c$ is a condition then $\texttt{true||} c \rightarrow \texttt{true}$.

\item[CondRecurseAnd] If $c_{1}$, $c_{1}'$ and $c_{2}$ are conditions and $c_{1} \rightarrow c_{1}'$, then
$c_{1}\texttt{\&\&}c_{2} \rightarrow c_{1}'\texttt{\&\&}c_{2}$.
\item[CondFalseAnd] If $c$ is a condition then $\texttt{false\&\&} c \rightarrow \texttt{false}$.
\item[CondTrueAnd] If $c$ is a condition then $\texttt{true\&\&} c \rightarrow c$.

\item[CondRecurseNot] If $c$ and $c'$ are conditions and $c \rightarrow c'$, then
$\texttt{!}c \rightarrow \texttt{!}c'$.
\item[CondTrueNot] $\texttt{!true} \rightarrow \texttt{false}$
\item[CondFalseNot] $\texttt{!false} \rightarrow \texttt{true}$

\end{description}

In a term rewrite system a formula is said to be \emph{normal} if no rules can be applied to reduce it.

\newtheorem{truefalsearenormal}{Theorem}
\begin{truefalsearenormal}
The conditions \texttt{true} and \texttt{false} are normal.
\end{truefalsearenormal}

\begin{proof}
The proof consist of looking through the rules and noticing that there are no reduction rules that apply to the conditions \texttt{true} and \texttt{false}.
\end{proof}

A term rewrite system is said to be \emph{deterministic} if and only if every formula can be reduced to at most one new formula in a single reduction step, or stated equivalently, if $t$, $t'$ and $t''$ are formulas such that $t \rightarrow t'$ and $t \rightarrow t''$, then $t' = t''$.

\newtheorem{conditiondeterminism}{Theorem}
\begin{conditiondeterminism}
The evaluation of a condition is deterministic.
\end{conditiondeterminism}

\begin{proof}

A determinism proof is accomplished by showing that if $t \rightarrow t'$ and $t \rightarrow t''$, then $t' = t''$.  More specifically, we proceed by cases, we use the symbol $t'$ to represent the right hand side of the reduction $t \rightarrow t'$ and for each rule we find a formula for the left hand side of the reduction, and show that it can only be reduced by applying that rule, implying that $t' = t''$.

\textbf{CondPrim} is the only rule that can apply to a primitive condition, i.e., a member of $C$.

If a condition is an or (\texttt{||}), then only \textbf{CondRecurseOr}, \textbf{CondTrueOr} and \textbf{CondFalseOr} potentially apply.  Clearly \textbf{CondTrueOr} and \textbf{CondFalseOr} are mutually exclusive, since the first term of the or cannot be both true or false.  But since both true and false are normal, both are also exclusive with \textbf{CondRecurseOr}, so at most one of these three can apply.

A similar situations exists for the triples \textbf{CondRecurseAnd}, \textbf{CondTrueAnd} and \textbf{CondFalseAnd}, and \textbf{CondRecurseNot}, \textbf{CondTrueNot} and \textbf{CondFalseNot}.

\end{proof}

(TODO: Prove that true and false are unique normals and that condition evaluation is normalizing, i.e., every condition evaluation terminates with a result of true or false.  This means that there is a computable function for evaluating conditions, we will define it and use it in program evaluation.)

\subsection{Programs}

A Generalized While program is evaluated by applying a sequence of reductions in the presence of a program state, which is a member of $S$.  Some special reductions change the program state, some are dependent on the program state.

\begin{description}


\item[foo] If $m$ is a member of $M$, then $m \rightarrow \texttt{pass}$, accompanied by a change to the program state where the current state $s$ is replaced by $s' = \delta_{1}(m, s)$.
\item[foo] If $p$ is a program then $\texttt{pass;}p \rightarrow p$.
\item[foo] If $p_{1}$ and $p_{2}$ are programs and $p_{1} \rightarrow p_{1}'$ then $p_{1}\texttt{;}p_{2} \rightarrow p_{1}'\texttt{;}p_{2}$.

\item[foo] If $p_{1}$ and $p_{2}$ are programs and $c$ and $c'$ are conditions such that $c \rightarrow c'$ then $\texttt{if } c \texttt{ then } p_{1} \texttt{ else } p_{2} \rightarrow \texttt{if } c' \texttt{ then } p_{1} \texttt{ else } p_{2}$.
\item[foo] If $p_{1}$ and $p_{2}$ are programs then $\texttt{if true then } p_{1} \texttt{ else } p_{2} \rightarrow p_{1}$.
\item[foo] If $p_{1}$ and $p_{2}$ are programs then $\texttt{if false then } p_{1} \texttt{ else } p_{2} \rightarrow p_{2}$.

\item[foo] If $c$ is a condition and $p$ is a program then \\ $\texttt{while } c \texttt{ do } p \rightarrow \texttt{if } c \texttt{ then (} p \texttt{; while } c \texttt{ do } p \texttt{) else pass}$.
\end{description}

We notice that all of these reductions are type preserving, a condition can only reduce to another condition and a program can only reduce to another program.  A condition cannot reduce to a program or vice versa.

\section{Some Theorems about Evaluation}

In a term rewrite system a formula is said to be normal if no rules can be applied to reduce it.

\newtheorem{passisnormal}{Theorem}
\begin{passisnormal}
The program \texttt{pass} is normal.
\end{passisnormal}

\begin{proof}
The proof consist of looking through the rules and noticing that there is no rule that applies to the program \texttt{pass}.
\end{proof}

A term rewrite system is said to be deterministic if and only if every formula can be reduced to at most one new formula in a single reduction step, or stated equivalently, if $t$, $t'$ and $t''$ are formulas such that $t \rightarrow t'$ and $t \rightarrow t''$, then $t' = t''$.

\newtheorem{determinism}{Theorem}
\begin{determinism}
The evaluation of a Generalized While program is deterministic.
\end{determinism}

\begin{proof}

A determinism proof is accomplished by showing that if $t \rightarrow t'$ and $t \rightarrow t''$, then $t' = t''$.  More specifically, we proceed by cases, we use the symbol $t'$ to represent the right hand side of the reduction $t \rightarrow t'$ and for each rule we find a formula for the left hand side of the reduction, and show that it can only be reduced by applying that rule, implying that $t' = t''$.

\begin{itemize}

\item
\begin{enumerate}
\item If $m$ is a member of $M$, then $m \rightarrow \texttt{pass}$, accompanied by a change to the program state where the current state $s$ is replaced by $s' = \delta_{1}(m, s)$.
\item We note in this case that the left hand side of the reduction is a member of $M$, and no other rule can apply.
\end{enumerate}

\item
\begin{enumerate}
\item If $p$ is a program then $\texttt{pass;}p \rightarrow p$.
\item The only other rule that might apply to the left hand side is one that allows us to reduce \texttt{pass} further, but since it's normal we can't do this.
\end{enumerate}

\item
\begin{enumerate}
\item If $p_{1}$ and $p_{2}$ are programs and $p_{1} \rightarrow p_{1}'$ then $p_{1}\texttt{;}p_{2} \rightarrow p_{1}'\texttt{;}p_{2}$.
\item Similarly we notice that the only other rule that might apply is the elimination of \texttt{pass}, but because $p_{1} \rightarrow p_{1}'$ and \texttt{pass} is normal, this rule will never apply to such a program.
\end{enumerate}

\item
\begin{enumerate}
\item If $c$ is a member of $C$ then $c \rightarrow \delta_{2}(c, s)$.
\item No other reduction rule exists for a primitive condition.
\end{enumerate}

\item
\begin{enumerate}
\item If $c$ is a condition then $\texttt{false||} c \rightarrow c$.
\item foobar foobar foobar
\end{enumerate}

\item
\begin{enumerate}
\item If $c$ is a condition then $\texttt{true||} c \rightarrow \texttt{true}$.
\item foobar foobar foobar
\end{enumerate}

\item
\begin{enumerate}
\item If $c$ is a condition then $\texttt{false\&\&} c \rightarrow \texttt{false}$.
\item foobar foobar foobar
\end{enumerate}

\item
\begin{enumerate}
\item If $c$ is a condition then $\texttt{true\&\&} c \rightarrow c$.
\item foobar foobar foobar
\end{enumerate}

\item
\begin{enumerate}
\item $\texttt{!true} \rightarrow \texttt{false}$
\item foobar foobar foobar
\end{enumerate}

\item
\begin{enumerate}
\item $\texttt{!false} \rightarrow \texttt{true}$
\item foobar foobar foobar
\end{enumerate}

\item
\begin{enumerate}
\item If $p_{1}$ and $p_{2}$ are programs and $c$ and $c'$ are conditions such that $c \rightarrow c'$ then $\texttt{if } c \texttt{ then } p_{1} \texttt{ else } p_{2} \rightarrow \texttt{if } c' \texttt{ then } p_{1} \texttt{ else } p_{2}$.
\item foobar foobar foobar
\end{enumerate}

\item
\begin{enumerate}
\item If $p_{1}$ and $p_{2}$ are programs then $\texttt{if true then } p_{1} \texttt{ else } p_{2} \rightarrow p_{1}$.
\item foobar foobar foobar
\end{enumerate}

\item
\begin{enumerate}
\item If $p_{1}$ and $p_{2}$ are programs then $\texttt{if false then } p_{1} \texttt{ else } p_{2} \rightarrow p_{2}$.
\item foobar foobar foobar
\end{enumerate}

\item
\begin{enumerate}
\item If $c$ is a condition and $p$ is a program then $\texttt{while } c \texttt{ do } p \rightarrow \texttt{if } c \texttt{ then (} p \texttt{; while } c \texttt{ do } p \texttt{) else pass}$.
\item foobar foobar foobar
\end{enumerate}

\end{itemize}

\end{proof}

A formula is referred to as normal if and only if there is no rule that can reduce it.

\newtheorem{passisuniquelynormal}{Theorem}
\begin{passisuniquelynormal}
No program except for \texttt{pass} is normal.
\end{passisuniquelynormal}

\begin{proof}
(TODO: Do proof...)
\end{proof}


\section{Data Flow Analysis of A Generalized While Program}

Let $P$ be a set of partitions of $S$ with the usual conditions, i.e., $P$ is pairwise disjoint and $\bigcup P = S$.  Let us assume the following:

\begin{itemize}
\item There is a computable function $\delta_{3} : M \times P \rightarrow \mathcal{P}(P)$.
\item There is a computable function $\delta_{4} : C \times P \rightarrow \mathcal{P}(\mathbb{B})$
\item $P$ is finite.
\end{itemize}

Then we can compute the function of type P $\rightarrow \mathcal{P}(P)$ that the program corresponds to.

(TODO: Explain...)
(IDEA: Define two forms, "expression form" and "control graph" form for Generalized While Program, explain these, explain how to interconvert)

\section{Other Things}
Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum 

\end{document}
